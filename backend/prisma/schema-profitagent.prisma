// ProFitAgent Database Schema
// Nueva estructura para el sistema de agentes externos y contratos inteligentes

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== MODELOS DE USUARIO =====
model User {
  id                            String                     @id @default(cuid())
  email                         String                     @unique
  password_hash                 String
  role                          UserRole                   @default(user)
  status                        UserStatus                 @default(active)
  ref_code                      String                     @unique
  sponsor_id                    String?
  usdt_bep20_address            String?
  telegram_user_id              String?                    @unique
  telegram_link_status          String?
  telegram_channel_access       Json?                      // Acceso a canales por nivel
  first_name                    String?
  last_name                     String?
  phone                         String?
  kyc_status                    KYCStatus                  @default(pending)
  kyc_data                      Json?
  created_at                    DateTime                   @default(now())
  updated_at                    DateTime                   @updatedAt
  telegram_username             String?                    @unique
  
  // Relaciones existentes
  audit_logs                    AuditLog[]                 @relation("ActorLogs")
  bonuses_created               Bonus[]                    @relation("BonusCreator")
  bonuses_received              Bonus[]                    @relation("BonusReceiver")
  ledger_entries                LedgerEntry[]
  notifications                 Notification[]
  orders                        OrderDeposit[]
  referral_commissions_referred ReferralCommission[]       @relation("ReferredRef")
  referral_commissions_sponsor  ReferralCommission[]       @relation("SponsorRef")
  licenses                      UserLicense[]
  notification_settings         UserNotificationSettings[] @relation("UserNotificationSettings")
  sponsor                       User?                      @relation("UserSponsor", fields: [sponsor_id], references: [id])
  sponsored                     User[]                     @relation("UserSponsor")
  withdrawals_approved          Withdrawal[]               @relation("WithdrawalApprover")
  withdrawals                   Withdrawal[]
  
  // Nuevas relaciones para ProFitAgent
  smart_contracts               SmartContract[]
  agent_assignments             AgentAssignment[]
  telegram_interactions         TelegramInteraction[]

  @@map("users")
}

// ===== MODELOS DE LICENCIAS MEJORADAS =====
model LicenseProduct {
  id                    String         @id @default(cuid())
  name                  String         // "Básica", "Estándar", "Premium", "Elite", "Enterprise"
  code                  String         @unique // "basic", "standard", "premium", "elite", "enterprise"
  price_usdt            Decimal        @db.Decimal(10, 2)
  daily_rate            Decimal        @db.Decimal(5, 4) // 8% = 0.08
  duration_days         Int            @default(25)
  agent_type            AgentAccessType // "shared", "personalized", "complete"
  included_agents       Json           // Lista de agentes incluidos
  max_cap_percentage    Decimal        @db.Decimal(5, 2)
  cashback_cap          Decimal        @default(1.00) @db.Decimal(5, 2)
  potential_cap         Decimal        @default(1.00) @db.Decimal(5, 2)
  recommended_capital   Decimal?       @db.Decimal(12, 2) // Capital recomendado
  telegram_channel_id   String?        // Canal de Telegram asociado
  support_level         SupportLevel   @default(basic)
  description           String?
  features              Json?          // Características específicas
  sla_hours             Int?           // Tiempo de respuesta de soporte
  badge                 String?
  target_user           String?
  status                String         @default("active")
  active                Boolean        @default(true)
  created_at            DateTime       @default(now())
  updated_at            DateTime       @updatedAt
  
  orders                OrderDeposit[]
  licenses              UserLicense[]

  @@map("license_products")
}

model UserLicense {
  id                    String                @id @default(cuid())
  user_id               String
  product_id            String
  order_id              String
  principal_usdt        Decimal               @db.Decimal(10, 2)
  total_earned_usdt     Decimal               @default(0) @db.Decimal(10, 2)
  cashback_accum        Decimal               @default(0) @db.Decimal(20, 6)
  potential_accum       Decimal               @default(0) @db.Decimal(20, 6)
  status                LicenseStatus         @default(active)
  days_generated        Int                   @default(0)
  pause_potential       Boolean               @default(false)
  smart_contract_id     String?               // Contrato inteligente asociado
  agent_assignments     Json?                 // Asignaciones de agentes
  performance_metrics   Json?                 // Métricas de rendimiento
  flags                 Json                  @default("{}")
  started_at            DateTime              @default(now())
  ends_at               DateTime
  created_at            DateTime              @default(now())
  updated_at            DateTime              @updatedAt
  
  earnings              LicenseDailyEarning[]
  product               LicenseProduct        @relation(fields: [product_id], references: [id])
  user                  User                  @relation(fields: [user_id], references: [id])
  smart_contract        SmartContract?        @relation(fields: [smart_contract_id], references: [id])
  agent_assignments_rel AgentAssignment[]

  @@map("user_licenses")
}

// ===== MODELOS DE AGENTES EXTERNOS =====
model AgentInfo {
  id                    String              @id @default(cuid())
  name                  String              // "Agente de Arbitraje Cripto Básico"
  code                  String              @unique // "crypto_arbitrage_basic"
  type                  AgentType           // "crypto_arbitrage", "surebet", "grid_trading", etc.
  access_level          AgentAccessType     // "shared", "personalized", "complete"
  description           String
  expected_roi          Json                // ROI esperado por período
  risk_level            RiskLevel           // "low", "medium", "high"
  min_capital           Decimal?            @db.Decimal(12, 2)
  max_capital           Decimal?            @db.Decimal(12, 2)
  supported_exchanges   Json?               // Exchanges soportados
  supported_pairs       Json?               // Pares de trading soportados
  configuration         Json?               // Configuración del agente
  performance_history   Json?               // Historial de rendimiento
  status                AgentStatus         @default(active)
  version               String              @default("1.0.0")
  last_update           DateTime            @default(now())
  created_at            DateTime            @default(now())
  updated_at            DateTime            @updatedAt
  
  assignments           AgentAssignment[]
  monitoring_logs       AgentMonitoringLog[]

  @@map("agent_info")
}

model AgentAssignment {
  id                    String              @id @default(cuid())
  user_id               String
  license_id            String
  agent_id              String
  access_type           AgentAccessType     // "shared", "personalized", "complete"
  allocation_percentage Decimal             @db.Decimal(5, 2) // % del capital asignado
  configuration         Json?               // Configuración específica del usuario
  status                AssignmentStatus    @default(active)
  performance_data      Json?               // Datos de rendimiento
  last_sync             DateTime?           // Última sincronización
  started_at            DateTime            @default(now())
  ended_at              DateTime?
  created_at            DateTime            @default(now())
  updated_at            DateTime            @updatedAt
  
  user                  User                @relation(fields: [user_id], references: [id])
  license               UserLicense         @relation(fields: [license_id], references: [id])
  agent                 AgentInfo           @relation(fields: [agent_id], references: [id])
  monitoring_logs       AgentMonitoringLog[]

  @@unique([user_id, license_id, agent_id])
  @@map("agent_assignments")
}

model AgentMonitoringLog {
  id                    String              @id @default(cuid())
  assignment_id         String
  agent_id              String
  log_type              MonitoringLogType   // "performance", "error", "trade", "sync"
  data                  Json                // Datos del log
  metrics               Json?               // Métricas específicas
  timestamp             DateTime            @default(now())
  created_at            DateTime            @default(now())
  
  assignment            AgentAssignment     @relation(fields: [assignment_id], references: [id])
  agent                 AgentInfo           @relation(fields: [agent_id], references: [id])

  @@index([agent_id, timestamp])
  @@index([assignment_id, timestamp])
  @@map("agent_monitoring_logs")
}

// ===== MODELOS DE CONTRATOS INTELIGENTES =====
model SmartContract {
  id                    String              @id @default(cuid())
  user_id               String
  contract_address      String              @unique
  contract_type         ContractType        // "license", "payment", "escrow"
  network               String              @default("BSC") // Binance Smart Chain
  balance_usdt          Decimal             @default(0) @db.Decimal(18, 6)
  total_deposits        Decimal             @default(0) @db.Decimal(18, 6)
  total_withdrawals     Decimal             @default(0) @db.Decimal(18, 6)
  total_returns         Decimal             @default(0) @db.Decimal(18, 6)
  last_distribution     DateTime?
  next_distribution     DateTime?
  status                ContractStatus      @default(active)
  audit_hash            String?             // Hash de auditoría
  deployment_tx         String?             // TX de despliegue
  configuration         Json?               // Configuración del contrato
  created_at            DateTime            @default(now())
  updated_at            DateTime            @updatedAt
  
  user                  User                @relation(fields: [user_id], references: [id])
  licenses              UserLicense[]
  transactions          ContractTransaction[]

  @@map("smart_contracts")
}

model ContractTransaction {
  id                    String              @id @default(cuid())
  contract_id           String
  tx_hash               String              @unique
  tx_type               TransactionType     // "deposit", "withdrawal", "distribution", "fee"
  amount_usdt           Decimal             @db.Decimal(18, 6)
  from_address          String?
  to_address            String?
  gas_used              String?
  gas_price             String?
  block_number          String?
  status                TxStatus            @default(pending)
  confirmed_at          DateTime?
  metadata              Json?
  created_at            DateTime            @default(now())
  
  contract              SmartContract       @relation(fields: [contract_id], references: [id])

  @@index([contract_id, created_at])
  @@index([tx_hash])
  @@map("contract_transactions")
}

// ===== MODELOS DE TELEGRAM =====
model TelegramChannel {
  id                    String              @id @default(cuid())
  channel_id            String              @unique // ID del canal de Telegram
  channel_name          String              // Nombre del canal
  channel_type          ChannelType         // "basic", "standard", "premium", "elite", "enterprise"
  access_level          String              // Nivel de acceso requerido
  description           String?
  invite_link           String?             // Link de invitación
  member_count          Int                 @default(0)
  status                ChannelStatus       @default(active)
  bot_token             String?             // Token del bot asociado
  welcome_message       String?
  rules                 Json?               // Reglas del canal
  features              Json?               // Características del canal
  created_at            DateTime            @default(now())
  updated_at            DateTime            @updatedAt
  
  interactions          TelegramInteraction[]

  @@map("telegram_channels")
}

model TelegramBot {
  id                    String              @id @default(cuid())
  bot_token             String              @unique
  bot_username          String              @unique
  bot_name              String
  bot_type              BotType             // "support", "trading", "notifications", "admin"
  commands              Json?               // Comandos disponibles
  webhook_url           String?
  status                BotStatus           @default(active)
  configuration         Json?               // Configuración del bot
  last_activity         DateTime?
  created_at            DateTime            @default(now())
  updated_at            DateTime            @updatedAt
  
  interactions          TelegramInteraction[]

  @@map("telegram_bots")
}

model TelegramInteraction {
  id                    String              @id @default(cuid())
  user_id               String
  channel_id            String?
  bot_id                String?
  interaction_type      InteractionType     // "message", "command", "callback", "join", "leave"
  content               String?
  metadata              Json?               // Datos adicionales
  response              String?             // Respuesta del bot
  status                InteractionStatus   @default(processed)
  timestamp             DateTime            @default(now())
  
  user                  User                @relation(fields: [user_id], references: [id])
  channel               TelegramChannel?    @relation(fields: [channel_id], references: [id])
  bot                   TelegramBot?        @relation(fields: [bot_id], references: [id])

  @@index([user_id, timestamp])
  @@index([channel_id, timestamp])
  @@map("telegram_interactions")
}

// ===== MODELOS EXISTENTES (mantenidos) =====
model AdminWallet {
  id               String         @id @default(cuid())
  label            String
  address          String         @unique
  status           String         @default("active")
  last_assigned_at DateTime?
  assigned_count   Int            @default(0)
  created_at       DateTime       @default(now())
  updated_at       DateTime       @updatedAt
  orders           OrderDeposit[]

  @@map("admin_wallets")
}

model OrderDeposit {
  id                 String         @id @default(cuid())
  user_id            String
  product_id         String
  amount_usdt        Decimal        @db.Decimal(10, 2)
  wallet_address     String
  tx_hash            String?
  status             OrderStatus    @default(pending)
  reserved_wallet_id String?
  payment_method     String         @default("USDT_BEP20") // Actualizado para BEP20
  paid_at            DateTime?
  confirmed_at       DateTime?
  raw_chain_payload  Json?
  expires_at         DateTime
  created_at         DateTime       @default(now())
  updated_at         DateTime       @updatedAt
  product            LicenseProduct @relation(fields: [product_id], references: [id])
  reserved_wallet    AdminWallet?   @relation(fields: [reserved_wallet_id], references: [id])
  user               User           @relation(fields: [user_id], references: [id])

  @@map("orders_deposits")
}

model LicenseDailyEarning {
  id                 String      @id @default(cuid())
  license_id         String
  day_index          Int
  earning_date       DateTime
  cashback_amount    Decimal     @db.Decimal(20, 6)
  potential_amount   Decimal     @db.Decimal(20, 6)
  applied_to_balance Boolean     @default(false)
  applied_at         DateTime?
  smart_contract_tx  String?     // TX del contrato inteligente
  created_at         DateTime    @default(now())
  license            UserLicense @relation(fields: [license_id], references: [id])

  @@unique([license_id, earning_date])
  @@map("license_daily_earnings")
}

model ReferralCommission {
  id               String           @id @default(cuid())
  sponsor_id       String
  referred_user_id String
  license_id       String
  order_id         String?
  amount_usdt      Decimal          @db.Decimal(10, 2)
  status           CommissionStatus @default(pending)
  release_at       DateTime?
  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt
  referred_user    User             @relation("ReferredRef", fields: [referred_user_id], references: [id])
  sponsor          User             @relation("SponsorRef", fields: [sponsor_id], references: [id])

  @@map("referral_commissions")
}

model Bonus {
  id                  String      @id @default(cuid())
  user_id             String
  amount_usdt         Decimal     @db.Decimal(18, 6)
  status              BonusStatus @default(pending)
  reason              String?
  created_by_admin_id String?
  created_at          DateTime    @default(now())
  updated_at          DateTime    @updatedAt
  created_by          User?       @relation("BonusCreator", fields: [created_by_admin_id], references: [id])
  user                User        @relation("BonusReceiver", fields: [user_id], references: [id])

  @@map("bonuses")
}

model Withdrawal {
  id                   String           @id @default(cuid())
  user_id              String
  amount_usdt          Decimal          @db.Decimal(18, 6)
  payout_address       String?
  status               WithdrawalStatus @default(requested)
  otp_id               String?
  otp_code_hash        String?
  otp_sent_at          DateTime?
  otp_verified_at      DateTime?
  approved_by_admin_id String?
  paid_at              DateTime?
  paid_tx_hash         String?
  smart_contract_tx    String?          // TX del contrato inteligente
  notes                String?
  created_at           DateTime         @default(now())
  updated_at           DateTime         @updatedAt
  approved_by          User?            @relation("WithdrawalApprover", fields: [approved_by_admin_id], references: [id])
  user                 User             @relation(fields: [user_id], references: [id])

  @@map("withdrawals")
}

model LedgerEntry {
  id                      String          @id @default(cuid())
  user_id                 String
  amount                  Decimal         @db.Decimal(18, 6)
  direction               LedgerDirection
  ref_type                LedgerRefType
  ref_id                  String?
  available_balance_after Decimal?        @db.Decimal(18, 6)
  smart_contract_ref      String?         // Referencia al contrato inteligente
  meta                    Json?
  created_at              DateTime        @default(now())
  user                    User            @relation(fields: [user_id], references: [id])

  @@map("ledger_entries")
}

model AuditLog {
  id            String   @id @default(cuid())
  actor_user_id String?
  action        String
  entity        String
  entity_id     String?
  old_values    Json?
  new_values    Json?
  diff          Json?
  ip_address    String?
  user_agent    String?
  created_at    DateTime @default(now())
  actor         User?    @relation("ActorLogs", fields: [actor_user_id], references: [id])

  @@map("audit_logs")
}

model Notification {
  id         String               @id @default(cuid())
  user_id    String
  type       NotificationType
  title      String
  message    String
  severity   NotificationSeverity @default(info)
  read_at    DateTime?
  meta       Json?
  created_at DateTime             @default(now())
  updated_at DateTime             @updatedAt
  user       User                 @relation(fields: [user_id], references: [id])

  @@index([user_id, created_at])
  @@index([type, created_at])
  @@map("notifications")
}

model UserNotificationSettings {
  id                String           @id @default(cuid())
  user_id           String
  notification_type NotificationType
  enabled           Boolean          @default(true)
  email_enabled     Boolean          @default(false)
  push_enabled      Boolean          @default(true)
  telegram_enabled  Boolean          @default(true) // Habilitado por defecto
  created_at        DateTime         @default(now())
  updated_at        DateTime         @updatedAt
  user              User             @relation("UserNotificationSettings", fields: [user_id], references: [id])

  @@unique([user_id, notification_type])
  @@map("user_notification_settings")
}

model Setting {
  key        String   @id
  value      Json
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("settings")
}

// ===== ENUMS EXISTENTES =====
enum UserRole {
  user
  admin
}

enum UserStatus {
  active
  suspended
  deleted
}

enum OrderStatus {
  pending
  expired
  paid
  confirmed
  canceled
}

enum LicenseStatus {
  active
  paused
  completed
  canceled
  pending
}

enum CommissionStatus {
  pending
  released
  canceled
}

enum BonusStatus {
  pending
  released
  canceled
}

enum WithdrawalStatus {
  requested
  otp_sent
  otp_verified
  approved
  paid
  rejected
  canceled
  expired
}

enum LedgerDirection {
  credit
  debit
}

enum LedgerRefType {
  order
  license
  earning
  referral_commission
  bonus
  withdrawal
  admin_adjustment
  system
  smart_contract
  agent_performance
}

enum NotificationType {
  withdrawal
  order
  earning
  system
  security
  bonus
  referral
  agent_performance
  smart_contract
  telegram
}

enum NotificationSeverity {
  info
  success
  warning
  error
}

// ===== NUEVOS ENUMS PARA PROFITAGENT =====
enum KYCStatus {
  pending
  approved
  rejected
  expired
}

enum AgentType {
  crypto_arbitrage
  surebet
  grid_trading
  defi_yield_farming
  scalping
  market_making
  cross_chain_arbitrage
}

enum AgentAccessType {
  shared
  personalized
  complete
}

enum AgentStatus {
  active
  maintenance
  inactive
  deprecated
}

enum RiskLevel {
  low
  medium
  high
}

enum AssignmentStatus {
  active
  paused
  completed
  error
}

enum MonitoringLogType {
  performance
  error
  trade
  sync
  alert
}

enum ContractType {
  license
  payment
  escrow
  distribution
}

enum ContractStatus {
  active
  paused
  terminated
  upgrading
}

enum TransactionType {
  deposit
  withdrawal
  distribution
  fee
  refund
}

enum TxStatus {
  pending
  confirmed
  failed
  reverted
}

enum ChannelType {
  basic
  standard
  premium
  elite
  enterprise
  admin
}

enum ChannelStatus {
  active
  inactive
  archived
}

enum BotType {
  support
  trading
  notifications
  admin
  monitoring
}

enum BotStatus {
  active
  inactive
  maintenance
}

enum InteractionType {
  message
  command
  callback
  join
  leave
  reaction
}

enum InteractionStatus {
  processed
  pending
  failed
}

enum SupportLevel {
  basic
  standard
  priority
  vip
  enterprise
}